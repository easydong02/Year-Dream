list1=['동희','호로록']  #2개의 원소를 가진 리스트 생성
print(list1)

list1.append(30)
print(list1) #append 메서드 사용하면 리스트를 생성한 후에 값을 추가할 수 있습니다.


list1.insert(0,40)
list1 #`insert` 메서드로 특정 위치에 값을 추가할 수 있습니다. 


interest = ["삼성전자", "LG전자", "카카오"]  #문자열과 마찬가지로 인덱싱과 슬라이싱 가능
interest[0][:2]

interest[0] = "동희"  #리스트에는 각 원소가 따로 메모리 배정 받아서 인덱스가 참조하고 있기 때문에 수정 가능
print(interest)

interest.remove('카카오') #remove 메서드는 삭제할 값을 입력받아 리스트에서 제거합니다.


print(interest.pop(0))  #pop 메서드는 인덱스를 입력받아 하나의 값을 제거합니다.

del interest[0]
print(interest) #del 키워드를 사용해서 제거할 수도 있습니다.

리스트 = ["101호", "102호", "103호", "104호", "105호", "106호", "107호"]
리스트.index('101호')  # index 메서드 구체적인 원소의 인덱스 번호 반환



# 연습문제 이름 적으면 인접한 가구 출력
거주순서 = ["아름", "종훈", "현호", "시후", "아라", "정현"]

name = input("이름:") #사용자가 직접 입력가능, 이 때 자료형은 문자열이므로 숫자를 입력할 때는 형변환 필수

if name in 거주순서:  #조건 입력받은 문자가 리스트에 있다면
  x=거주순서.index(name) #그 이름으로 인덱스 번호 추출 후 변수에 대입
  print("{}에 인접한 두 집은 {},{}입니다.".format(name,거주순서[x-1],거주순서[x+1]))  #인덱스의 앞 뒤 인덱스를 출력
 
 
list1=['c','b','a']  #sort 정렬 메서드
list1.sort()


list1.reverse() #가운데 인덱스를 기준으로 대칭 정렬 역정렬 하고 싶으면 sort()를 먼저하고 reverse()를 하자

list1

'@@@'.join(list1)  #join연산자는 각 원소사이에 입력한 데이터를 끼워 넣기 가능


print(id(리스트[0]))
리스트[0] ='C'
print(id(리스트[0]))   # 0번째 인덱스가 달라졌다면 주소값도 바뀜, 아니라면 원래 생성된 메모리 주소를 가리키므로 달라지지 않습니다.


 

 
  
 
